<!--
SPDX-FileCopyrightText: 2025 The Crossplane Authors <https://crossplane.io>

SPDX-License-Identifier: Apache-2.0
-->

# Upjet Managed Resource API Lifecycle Policy

* Owner: Sergen Yalcin (@sergenyalcin)
* Reviewers: Upjet Maintainers, Upjet Community
* Status: Draft

## Background

Upjet-based providers have supported multi-version CRDs and conversion mechanisms
since [v1.1.0](https://github.com/crossplane/upjet/releases/tag/v1.1.0). The
original motivation was to prevent breaking API changes caused by underlying
Terraform provider schema updates—singleton list to embedded object
transformations were the first major use case. This capability became
foundational, allowing providers to introduce new API versions, handle
provider-specific version differences, and reduce user-facing breaking changes
through conversion consistency.

However, version management across providers has remained largely ad-hoc. While
the technical mechanisms for multi-version CRDs exist, there is no formal API
Versioning Policy defining when a version should be introduced, deprecated, or
removed.

### Current Multi-Version Support

Upjet provides built-in facilities to manage multiple API versions:

| Component | Description |
|-----------|-------------|
| [PreviousVersions](https://github.com/crossplane/upjet/blob/acc66b90338f05b7fea66add14b0f42233493897/pkg/config/resource.go#L465) | Lists all previously supported API versions for a given resource |
| [StorageVersion](https://github.com/crossplane/upjet/blob/acc66b90338f05b7fea66add14b0f42233493897/pkg/config/resource.go#L522) | Defines the version in which objects are persisted in etcd |
| [CurrentVersion](https://github.com/crossplane/upjet/blob/acc66b90338f05b7fea66add14b0f42233493897/pkg/config/resource.go#L460) | Indicates the latest version currently generated by the provider |
| [HubVersion](https://github.com/crossplane/upjet/blob/acc66b90338f05b7fea66add14b0f42233493897/pkg/config/resource.go#L529) | Serves as the central version used for conversion between older and newer versions |
| [ControllerVersion](https://github.com/crossplane/upjet/blob/acc66b90338f05b7fea66add14b0f42233493897/pkg/config/resource.go#L475) | Specifies which version of the resource controller handles reconciliation |

The conversion layer includes:
- **API Conversion Function Interfaces** - Define contracts for transforming
resources between versions
- **ManagedConverter** (typed) - Type-safe converter for strongly-typed managed
resources
- **PavedConverter** (generic) - Generic converter using unstructured object
representations
- **Built-in conversion strategies** - Singleton List → Embedded Object, Field
Copy, Custom Converter templates
- **Conversion Function Registry** - Central registry for managing available
converters

### Problem Statement

The absence of a unified API Versioning Policy has led to several challenges:

1. **Lack of Formal Version Lifecycle Policy**: No defined policy for when/how
new API versions should be introduced, how long previous versions should remain
supported, or under what conditions older versions can be removed

2. **Version Backlog Risk**: Without clear removal policies, older versions
accumulate, necessitating manual (backporting fields) or automatic (webhook
framework) conversion across a broad version matrix

3. **Stagnant Storage Versions**: Almost all providers continue using `v1beta1`
as storage version even though newer versions (e.g., `v1beta2`) have been
introduced and stabilized. This arose because:
   - Immediate storage version bumps break downgrade compatibility (older
   providers can't read new storage schemas)
   - The initial decision to avoid immediate promotion was correct for safety
   - The lack of a migration policy made this temporary choice permanent
   - This prevents newer schemas from becoming canonical and complicates
   long-term maintenance

4. **CRD Size and API Server Overhead**: Retaining multiple historical versions
increases CRD manifest size and complexity. Each additional version contributes
to larger OpenAPI schemas, which the API server must load, validate, and serve.
While the impact hasn't been quantified across Upjet-based providers, pruning
older API versions is expected to reduce CRD size and improve API server
performance

5. **Undefined Deprecation Criteria**: Without a deprecation timeline or removal
process, deprecated versions remain indefinitely, causing API clutter, user
confusion during upgrades, and slower iteration cycles

## Goals

This proposal aims to establish a unified and structured API Version Lifecycle
Policy that:
- Defines when and how new API versions are introduced
- Establishes clear deprecation timelines and criteria
- Specifies conditions under which older versions can be removed
- Maintains backward compatibility as much as possible
- Provides consistency and predictability across all Upjet-based providers
- Enables safe upgrade and downgrade paths

## Non-Goals
- Defining **how** to implement version conversions technically (covered in
[Managing CRD Versions](managing-crd-versions.md))
- Retroactively changing existing provider versions already in production
- Automating version transitions in this initial policy (identified as future
work)
- Defining **when** to create new versions based on schema changes (covered in
existing documentation)

## Proposal

### Version Lifecycle Stages

The API version lifecycle follows a predictable sequence with four distinct
phases:

| Stage | Description | Key Actions | Compatibility Impact |
|-------|-------------|-------------|---------------------|
| **Introduced** | A new API version (e.g., v1beta2) is added alongside an existing version (v1beta1) | Generate CRDs for the latest version<br>Register necessary conversion functions | Full backward compatibility |
| **Bridge** | Transitional release where the new version is available but not yet used as StorageVersion | Keep old version as storage<br>Validate bidirectional conversion<br>Ensure downgrade path is preserved | Safe downgrade to previous release remains possible |
| **Deprecated** | The new version becomes StorageVersion and ControllerVersion; the old one is marked deprecated | Announce deprecation<br>Update CRD version metadata<br>Stop feature development for old version | Downgrade possible only via intermediate (bridge) release |
| **Removed** | Deprecated version is deleted after a grace period (at least one minor release) | Remove CRD and conversion entries<br>Announce as breaking change | Direct downgrade to pre-bridge releases no longer supported |

### Version Introduction and Bridge Concept

When a new API version is introduced, it enters a transitional phase called the
**Bridge Version**—a release that ensures downgrade safety while enabling
forward migration.

**Example Transition:**

| Release | v1beta1 | v1beta2 | Notes |
|---------|---------|---------|-------|
| v1.0.0 | storage=true, served=true | - | Initial version |
| v1.1.0 | storage=true, served=true | served=true | Bridge phase begins |
| v1.2.0 | storage=false, served=true, deprecated=true | storage=true, served=true | Storage promoted, v1beta1 deprecated |
| v1.3.0 | storage=false, served=false, deprecated=true | storage=true, served=true | v1beta1 no longer served (breaking) |
| v1.4.0 | Removed | storage=true, served=true | Full transition complete |

**Why Avoid Immediate Storage Promotion?**

Immediate storage version bumps break downgrade compatibility. If the storage
version is promoted when the version is introduced, all objects in etcd persist
using the new schema. If a user downgrades to a previous release unaware of the
new storage schema, the older provider fails to read or reconcile these
objects—Kubernetes cannot convert from an unknown storage version, effectively
"sticking" the cluster on the newer version.

The bridge release ensures both old and new versions are served simultaneously,
allowing a safe downgrade path while preventing etcd from being updated to a
schema that older provider versions cannot interpret.

### Storage and Controller Version Bump

**When to Promote:**

Once the Bridge Version condition is satisfied (new version present for at least
one release with backward conversions available), the **StorageVersion** should
be updated to the newer API version. This makes the new version canonical for
persistence.

**ControllerVersion Update:**

**ControllerVersion** should be updated **immediately** when a new API version
is introduced, even before the new version becomes StorageVersion. This ensures:
- Reconciliation uses the latest schema
- Controllers don't depend on deprecated versions
- Reconciliation logic aligns with the latest API surface

The trade-off is increased conversion activity while storage version remains
unchanged; however, this cost is acceptable given the maturity of the conversion
framework.

Not updating the `ControllerReconcileVersion` to the latest API version will
increase the runtime complexity. The controllers will need to handle the API
differences between the runtime Terraform API and the latest Crossplane CRD API.
Please see the example runtime overheads in this https://github.com/crossplane/upjet/pull/563.

Please note that the `ControllerReconcileVersion` field will be deprecated in
the upjet with the following deprecation notice:

```go
// Deprecated: ControllerReconcileVersion is deprecated and will be removed
// in a future release. Controllers should always reconcile using the latest
// available CRD version to avoid complexity in runtime conversion logic.
// When this field differs from Version, additional runtime overhead is
// incurred for field conversions between API versions via annotations.
// The recommended approach is to always keep ControllerReconcileVersion
// equal to Version.
```

Then in the providers, the controller (reconcile) API version will be set to the
latest MR API version, and it guarantees that the runtime will be equivalent
with the latest API.

### Deprecation Policy

When a new storage version becomes active:

- The previous version is marked as **deprecated immediately**
- Deprecation is announced in both:
  - Release notes
  - CRD's version description field
  - `spec.versions[].deprecationWarning` (native Kubernetes warning mechanism)
- Deprecated versions **must remain available for at least one subsequent minor
release**

**Deprecation Implications:**

- Version will not receive new features
- Only bug fixes or conversion-related patches accepted
- Removal may occur after one or more stable cycles, depending on provider
maturity

### Version Removal

Removing an API version constitutes a **breaking change** by definition.
However, given that major version bumps are infrequent for providers, controlled
removals may occur during a minor version release if **all** of the following
are true:

1. The deprecated version has been retained for at least one prior minor release
2. The newer storage version has been verified stable in production
3. Conversion logic is validated to ensure safe object reads from the deprecated
version
4. The removal is explicitly noted as a breaking change in release documentation

**Important Note:**

Setting `served=false` for an API version is a breaking change for any client
still issuing requests using that version. Even though conversion logic
continues to operate internally, external consumers lose the ability to interact
with that version via the Kubernetes API. For this reason, `served=false`
transitions must be documented under "Breaking Changes" in release notes.

### Sequential Upgrade and Downgrade Requirements

Upjet's bridge-version model introduces a **sequential upgrade and downgrade
requirement**:

- **Upgrades must follow N → N+1 ordering**
- **Downgrades must follow N → N-1 ordering**
- **Skipping versions is not supported**

Each release may introduce a new storage schema or serve/don't-serve
configuration that older versions cannot interpret.

This aligns with established Kubernetes ecosystem best practices:
- [Kubernetes kubeadm upgrade guidelines](https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade)
- [Amazon EKS in-place upgrade best practices](https://docs.aws.amazon.com/eks/latest/best-practices/cluster-upgrades.html#upgrade-clusters-in-place)

**Downgrade Compatibility:**

Per this policy, downgrade compatibility is only guaranteed across
**consecutive** provider releases (N → N-1), for example v1.2.0 → v1.1.0. Direct
downgrades that skip an intermediate release (e.g., v1.2.0 → v1.0.0) are **not
supported**.

This constraint follows directly from the bridge-version model: once etcd begins
to persist objects under a newer storage version schema, older releases unaware
of that schema cannot reliably read or reconcile those objects.

This design favors forward stability while providing a safe, one-step downgrade
path for recovery scenarios, at the cost of disallowing multi-step downgrades.

### Lifecycle Summary

1. **Introduce:** Add a new API version alongside the current one
2. **Bridge:** Maintain both versions, keeping the old one as storage
3. **Deprecate:** Promote the new version to storage and mark the old one
deprecated
4. **Block:** Set `served=false` to block (REST) clients from using the version
(conversions still possible)
5. **Remove:** After at least one release, remove the deprecated version under
controlled conditions

## Deprecation and Removal Schedule

### Triggers for Deprecation

A version enters **Deprecated** state when all of the following are true:

1. A newer API version has been introduced and promoted to StorageVersion and
ControllerVersion
2. Bidirectional conversion between the new and previous versions is validated
in CI (round-trip and schema equivalence checks)
3. Release notes explicitly announce the promotion and the deprecation

**Deprecation Window (minimum):** The deprecated version MUST remain served for
at least one subsequent minor provider release (grace period) after the new
storage version ships.

### Communication Requirements

For every deprecation:

- **Release notes:** Add a dedicated "Deprecated APIs" section listing
`<group/version, kind>` and target removal release (tentative)
- **CRD metadata:** Mark the version as deprecated in the description (e.g.,
"Deprecated: will be removed in vX.Y.0 or later") and/or via deprecation
annotation
- **Native warnings:** Populate `spec.versions[].deprecationWarning` for any
version entering Deprecated state—this ensures users interacting with the
deprecated version through tools like kubectl receive explicit CLI warnings
- **Documentation:** Link to a short migration guide (key field changes, known
pitfalls, example kubectl transforms)

### Removal Policy

Removing an API version is a breaking change. Because major bumps are rare,
removal may occur in a minor release as a **controlled breaking change** if ALL
conditions hold:

1. The version has been in Deprecated state for ≥ 1 minor release
2. Conversion stability of the newer storage version is proven in production
(no critical open issues)
3. Release notes clearly label the removal under "Breaking Changes" and restate
the supported downgrade path (N → N-1 only)

## Future Work

While this policy establishes a clear baseline, several areas can be extended in
future iterations:

### Automation in Upjet Generator

Future versions of the Upjet generator could automatically:
- Detect resources that meet the Bridge Version condition
- Update StorageVersion and ControllerVersion fields during generation
- Annotate deprecated versions in CRD manifests

This would reduce manual intervention and ensure version transitions are handled
consistently across providers.

### Documentation and Communication Templates

Standardized documentation practices could be adopted:
- A `VERSION_POLICY.md` or `VERSIONS.yaml` file per provider, listing all API
versions and their current lifecycle phase (Introduced, Bridge, Deprecated,
Removed)
- Template-based Release Notes entries to ensure consistent deprecation and
removal notices across providers

### Automated Breaking-Change Detection

Upjet-based providers include hundreds of CRDs, each with multiple API versions.
Manually preparing release notes for breaking changes is error-prone and does
not scale.

A more robust solution would be an automated tool that:
- Detects API-breaking changes by diffing successive CRDs
- Identifies field removals, type changes, and version removal events
- Emits standardized release-note fragments for provider maintainers

### Storage Version Migration Mechanisms

Promoting a new API version to StorageVersion requires all existing objects in
etcd to be migrated to the new schema. Without tooling, this depends on users
manually touching or updating resources, which is error-prone and can delay
version cleanup.

Kubernetes offers a general-purpose [Storage Version Migrator (SVM)](https://github.com/kubernetes-sigs/kube-storage-version-migrator),
but it's designed for cluster-wide migrations and may be too heavy for
Upjet-based providers with large numbers of managed resource CRDs.

A more scoped approach—a lightweight, provider-specific storage version
migrator—could automate storage conversions during provider upgrades and
significantly simplify version lifecycle management. This document does not
mandate such a tool but identifies it as a future direction worth evaluating.

## Alternatives Considered

### Always Promote Storage Version Immediately

**Alternative:** Promote the new API version to storage version immediately upon
introduction.

This breaks downgrade compatibility. Users who upgrade to a release with a new
storage version cannot safely roll back to earlier releases, as those releases
cannot read the new storage schema from etcd. The bridge-version model is
required to maintain safe downgrade paths.

### No Formal Deprecation Timeline

**Alternative:** Allow each provider to determine its own deprecation and
removal timeline ad-hoc.

This creates inconsistent user experiences across the Crossplane ecosystem.
Users cannot predict behavior across providers, and the lack of policy leads to
indefinite retention of old versions, increasing maintenance burden and CRD
bloat.

### Require Major Version Bumps for Removals

**Alternative:** Only allow API version removals during major provider releases
(e.g., v1.x.x → v2.0.0).

Major version bumps are rare in Crossplane providers. Waiting for major releases
would prevent timely cleanup of deprecated versions. The controlled breaking
change approach (with clear documentation) balances compatibility concerns with
maintenance needs.

### Support Multi-Step Upgrades/Downgrades

**Alternative:** Allow users to skip intermediate versions (e.g.,
v1.0.0 → v1.3.0 directly).

This would require maintaining conversion paths across all historical version
combinations, exponentially increasing complexity. The sequential upgrade
requirement aligns with Kubernetes ecosystem practices(kubeadm, managed services)
and simplifies conversion logic.

---

**Related Documentation:**
- [Managing CRD Versions](managing-crd-versions.md) -
Technical implementation guide for CRD version management
- [Kubernetes API Versioning](https://kubernetes.io/docs/reference/using-api/#api-versioning)
- [Upjet Multi-Version Support v1.1.0](https://github.com/crossplane/upjet/releases/tag/v1.1.0)
