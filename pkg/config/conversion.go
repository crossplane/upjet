// SPDX-FileCopyrightText: 2025 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

package config

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/crossplane/crossplane-runtime/v2/pkg/errors"
	schemav2 "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/upbound/uptest/pkg/crdschema"

	"github.com/crossplane/upjet/v2/pkg/config/conversion"
)

// RegisterAutoConversions automatically registers conversion functions
// for all resources in the provider based on detected CRD schema changes between API versions.
//
// This function analyzes the provided JSON data (generated by the crddiff tool) and automatically
// registers appropriate conversion functions for three types of breaking changes:
//   1. Field additions: Registers conversions to store/restore field values via annotations
//   2. Field deletions: Registers conversions to preserve deleted field data via annotations
//   3. Type changes: Registers type conversion functions (string↔number, string↔boolean)
//
// The function iterates through all resources in the provider and registers bidirectional
// conversions to ensure data integrity during upgrades (old→new) and downgrades (new→old).
//
// Resource Opt-out:
// Resources can disable auto-registration by setting:
//   r.AutoConversionRegistrationOptions.SkipAutoRegistration = true
//
// Resources can exclude specific paths from auto-registration using:
//   r.AutoConversionRegistrationOptions.AutoRegisterExcludePaths = []string{"spec.forProvider.fieldName"}
//
// Timing Requirements:
// This function must be called AFTER ExcludeTypeChangesFromIdentity and AFTER
// version bumping (e.g., singleton list conversions). The typical call order is:
//  1. pc.ConfigureResources()
//  2. ExcludeTypeChangesFromIdentity(pc, crdSchemaChanges)
//  3. Version bumping operations (e.g., bumpVersionsWithEmbeddedLists)
//  4. RegisterAutoConversions(pc, crdSchemaChanges)  ← This function
//
// Type Conversion Behavior:
//   - string->number: Consults Terraform schema to determine int vs float conversion
//   - number->string: Defaults to integer conversion (cannot access old schema)
//     Operators should exclude and manually register if the field was actually a float
//   - string<->boolean: Bidirectional conversion ("true"/"false" <-> true/false)
//
// Example:
//   if err := config.RegisterAutoConversions(pc, crdSchemaChangesJSON); err != nil {
//       return nil, errors.Wrap(err, "cannot inject CRD schema change conversion functions")
//   }
func RegisterAutoConversions(pc *Provider, crdSchemaChanges []byte) error {
	data, err := parseChangeReports(crdSchemaChanges)
	if err != nil {
		return errors.Wrap(err, "error parsing CRD schema change")
	}

	for _, r := range pc.Resources {
		// Skip resources that opt out of automatic conversion registration
		if r.AutoConversionRegistrationOptions.SkipAutoRegistration {
			continue
		}
		// Construct the key to look up this resource's change report
		// Format: "{shortGroup}.{rootGroup}/{kind}" e.g., "ec2.aws.upbound.io/VPC"
		key := fmt.Sprintf("%s.%s/%s", r.ShortGroup, pc.RootGroup, r.Kind)
		if changeReport, ok := data[key]; ok {
			// Process all version transitions (e.g., v1beta1 → v1beta2)
			for _, cv := range changeReport.Versions {
				for _, change := range cv.Changes {
					// Skip paths that are explicitly excluded by resource configuration
					if isExcludedPath(change.Path, r.AutoConversionRegistrationOptions.AutoRegisterExcludePaths) {
						continue
					}
					switch change.ChangeType {
					case crdschema.ChangeTypeFieldAdded:
						// Field was added in the new version
						// old→new: Restore field value from annotation (FromAnnotation)
						// new→old: Store field value in annotation (ToAnnotation)
						r.Conversions = append(r.Conversions, conversion.NewNewlyIntroducedFieldConversion(cv.OldVersion, cv.NewVersion, change.Path, conversion.FromAnnotation),
							conversion.NewNewlyIntroducedFieldConversion(cv.NewVersion, cv.OldVersion, change.Path, conversion.ToAnnotation))
					case crdschema.ChangeTypeFieldDeleted:
						// Field was removed in the new version
						// old→new: Store field value in annotation before removal (ToAnnotation)
						// new→old: Restore field value from annotation (FromAnnotation)
						r.Conversions = append(r.Conversions, conversion.NewNewlyIntroducedFieldConversion(cv.OldVersion, cv.NewVersion, change.Path, conversion.ToAnnotation),
							conversion.NewNewlyIntroducedFieldConversion(cv.NewVersion, cv.OldVersion, change.Path, conversion.FromAnnotation))
					case crdschema.ChangeTypeTypeChanged:
						// Field type changed between versions (e.g., string → number)
						switch {
						case change.OldValue == "string" && change.NewValue == "number":
							// Strip the spec.forProvider/spec.initProvider/status.atProvider prefix
							// to get the Terraform schema path
							schPath := trimPathPrefix(change.Path)
							if schPath == "" {
								// Path doesn't match expected prefixes, skip conversion
								continue
							}
							// Consult Terraform schema to determine if this is int or float
							sch := GetSchema(r.TerraformResource, schPath)
							if sch == nil {
								// Schema not found - skip this conversion
								continue
							}
							switch sch.Type { //nolint:exhaustive // only TypeFloat and TypeInt are relevant for string to number conversions
							case schemav2.TypeFloat:
								r.Conversions = append(r.Conversions, conversion.NewFieldTypeConversion(cv.OldVersion, cv.NewVersion, change.Path, conversion.StringToFloat),
									conversion.NewFieldTypeConversion(cv.NewVersion, cv.OldVersion, change.Path, conversion.FloatToString))
							case schemav2.TypeInt:
								r.Conversions = append(r.Conversions, conversion.NewFieldTypeConversion(cv.OldVersion, cv.NewVersion, change.Path, conversion.StringToInt),
									conversion.NewFieldTypeConversion(cv.NewVersion, cv.OldVersion, change.Path, conversion.IntToString))
							default:
								// Schema type is neither int nor float (e.g., TypeBool, TypeString)
								// This indicates a mismatch between CRD schema and Terraform schema
								return fmt.Errorf("unsupported type for number conversion in field %q: got Terraform schema type %q", change.Path, sch.Type)
							}
						case change.OldValue == "number" && change.NewValue == "string":
							// Number -> String conversion
							// Cannot determine if the old number was int or float without accessing old schema.
							// Default to integer conversion. Operators must exclude and manually register
							// if the field was actually a float to avoid precision loss.
							r.Conversions = append(r.Conversions, conversion.NewFieldTypeConversion(cv.OldVersion, cv.NewVersion, change.Path, conversion.IntToString),
								conversion.NewFieldTypeConversion(cv.NewVersion, cv.OldVersion, change.Path, conversion.StringToInt))
						case change.OldValue == "string" && change.NewValue == "boolean":
							// String → Boolean: "true"/"false" → true/false
							r.Conversions = append(r.Conversions, conversion.NewFieldTypeConversion(cv.OldVersion, cv.NewVersion, change.Path, conversion.StringToBool),
								conversion.NewFieldTypeConversion(cv.NewVersion, cv.OldVersion, change.Path, conversion.BoolToString))
						case change.OldValue == "boolean" && change.NewValue == "string":
							// Boolean → String: true/false → "true"/"false"
							r.Conversions = append(r.Conversions, conversion.NewFieldTypeConversion(cv.OldVersion, cv.NewVersion, change.Path, conversion.BoolToString),
								conversion.NewFieldTypeConversion(cv.NewVersion, cv.OldVersion, change.Path, conversion.StringToBool))
						}
					}
				}
			}
		}
	}
	return nil
}

// ExcludeTypeChangesFromIdentity excludes fields with type changes from the
// identity conversion function to prevent runtime conversion failures.
//
// Identity conversion copies fields as-is from source to target. When a field's type
// changes between API versions (e.g., string -> number), direct copying would fail.
// This function identifies all type-changed fields and adds them to the exclusion list
// so they are handled by specialized type conversion functions instead.
//
// This function MUST be called BEFORE RegisterAutoConversions and
// BEFORE version bumping operations. The excluded paths are used by:
//   1. Identity converters to skip type-changed fields
//   2. Singleton list converters to avoid copying incompatible types
//
// Timing Requirements:
// Call order MUST be:
//  1. pc.ConfigureResources()
//  2. ExcludeTypeChangesFromIdentity(pc, crdSchemaChanges)  ← This function
//  3. Version bumping operations (e.g., bumpVersionsWithEmbeddedLists)
//  4. RegisterAutoConversions(pc, crdSchemaChanges)
//
// Example:
//   if err := config.ExcludeTypeChangesFromIdentity(pc, crdSchemaChangesJSON); err != nil {
//       return nil, errors.Wrap(err, "cannot exclude type changes from identity conversion")
//   }
func ExcludeTypeChangesFromIdentity(pc *Provider, crdSchemaChanges []byte) error {
	data, err := parseChangeReports(crdSchemaChanges)
	if err != nil {
		return errors.Wrap(err, "error parsing CRD schema change")
	}

	for _, r := range pc.Resources {
		key := fmt.Sprintf("%s.%s/%s", r.ShortGroup, pc.RootGroup, r.Kind)
		if changeReport, ok := data[key]; ok {
			// Use a map to deduplicate paths across multiple version transitions
			m := map[string]bool{}
			for _, cv := range changeReport.Versions {
				for _, change := range cv.Changes {
					// Allow resources to opt-out of automatic exclusion for specific paths
					if isExcludedPath(change.Path, r.AutoConversionRegistrationOptions.AutoRegisterExcludePaths) {
						continue
					}
					// Only type changes need to be excluded from identity conversion
					// Field additions/deletions are handled fine by identity conversion
					if change.ChangeType == crdschema.ChangeTypeTypeChanged {
						setIdentityConversionExcludePath(r, change.Path, m)
					}
				}
			}
		}
	}
	return nil
}

func parseChangeReports(crdSchemaChanges []byte) (map[string]*crdschema.ChangeReport, error) {
	data := map[string]*crdschema.ChangeReport{}
	if err := json.Unmarshal(crdSchemaChanges, &data); err != nil {
		return nil, errors.Wrap(err, "failed to unmarshal CRD schema change conversion functions")
	}
	return data, nil
}

// trimPathPrefix removes the CRD API path prefix to get the Terraform schema path.
//
// CRD paths include prefixes like:
//   - "spec.forProvider.fieldName"
//   - "spec.initProvider.fieldName"
//   - "status.atProvider.fieldName"
//
// Terraform schema paths don't include these prefixes, just "fieldName".
// This function strips the prefix to enable Terraform schema lookups.
func trimPathPrefix(path string) string {
	switch {
	case strings.HasPrefix(path, pathForProvider):
		return strings.TrimPrefix(path, fmt.Sprintf("%s.", pathForProvider))
	case strings.HasPrefix(path, pathInitProvider):
		return strings.TrimPrefix(path, fmt.Sprintf("%s.", pathInitProvider))
	case strings.HasPrefix(path, pathAtProvider):
		return strings.TrimPrefix(path, fmt.Sprintf("%s.", pathAtProvider))
	default:
		// Path doesn't match expected CRD prefixes
		// This could happen if crddiff reports a path outside spec/status
		return ""
	}
}

// setIdentityConversionExcludePath adds a field path to the resource's identity conversion
// exclusion list, ensuring no duplicates are added.
//
// This function:
//  1. Strips CRD path prefixes using trimPathPrefix
//  2. Checks for empty paths (invalid/unexpected paths)
//  3. Deduplicates using the provided map
//  4. Appends to the resource's IdentityConversionExcludePaths
func setIdentityConversionExcludePath(r *Resource, fullPath string, m map[string]bool) {
	path := trimPathPrefix(fullPath)
	// Only add valid, non-duplicate paths
	if path != "" && !m[path] {
		r.AutoConversionRegistrationOptions.IdentityConversionExcludePaths = append(r.AutoConversionRegistrationOptions.IdentityConversionExcludePaths, path)
		m[path] = true
	}
}

// isExcludedPath checks if a given path is in the exclusion list.
func isExcludedPath(path string, excludePaths []string) bool {
	for _, excludePath := range excludePaths {
		if path == excludePath {
			return true
		}
	}
	return false
}
