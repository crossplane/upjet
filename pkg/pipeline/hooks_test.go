package pipeline

import (
	"fmt"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"

	"github.com/crossplane/upjet/v2/pkg/config"
)

// Helper function to verify marker position in the file
func verifyMarkerPosition(t *testing.T, content, typeName, marker string) {
	t.Helper()
	lines := strings.Split(content, "\n")

	// Find the type declaration line
	typeLineIdx := -1
	for i, line := range lines {
		if strings.Contains(line, "type "+typeName+" struct {") {
			typeLineIdx = i
			break
		}
	}
	if typeLineIdx == -1 {
		t.Fatalf("type %s not found in content", typeName)
	}

	// Find the marker line
	markerLineIdx := -1
	for i, line := range lines {
		if strings.TrimSpace(line) == marker {
			markerLineIdx = i
			break
		}
	}
	if markerLineIdx == -1 {
		t.Fatalf("marker %q not found in content", marker)
	}

	// Verify marker comes before the type declaration
	if markerLineIdx >= typeLineIdx {
		t.Errorf("marker %q at line %d should come before type %s at line %d", marker, markerLineIdx, typeName, typeLineIdx)
	}

	// Verify marker is in the kubebuilder marker block (within ~15 lines before type)
	if typeLineIdx-markerLineIdx > 15 {
		t.Errorf("marker %q at line %d is too far from type %s at line %d (distance: %d lines)",
			marker, markerLineIdx, typeName, typeLineIdx, typeLineIdx-markerLineIdx)
	}

	// Verify marker appears only once
	count := strings.Count(content, marker)
	if count != 1 {
		t.Errorf("marker %q appears %d times, want 1", marker, count)
	}
}

// Helper function to verify marker comes after another marker
func verifyMarkerOrder(t *testing.T, content, marker1, marker2 string) {
	t.Helper()
	idx1 := strings.Index(content, marker1)
	idx2 := strings.Index(content, marker2)

	if idx1 == -1 {
		t.Fatalf("marker %q not found", marker1)
	}
	if idx2 == -1 {
		t.Fatalf("marker %q not found", marker2)
	}

	if idx2 <= idx1 {
		t.Errorf("marker %q should come after %q, but found at positions %d and %d", marker2, marker1, idx2, idx1)
	}
}

// Helper function to verify deprecation notice in description
func verifyDeprecationNotice(t *testing.T, content, typeName, expectedNoticeSubstring string, shouldExist bool) {
	t.Helper()
	lines := strings.Split(content, "\n")

	// Find the type declaration line
	typeLineIdx := -1
	for i, line := range lines {
		if strings.Contains(line, "type "+typeName+" struct {") {
			typeLineIdx = i
			break
		}
	}
	if typeLineIdx == -1 {
		t.Fatalf("type %s not found in content", typeName)
	}

	// Find the description comment block (walk backwards from type)
	hasDeprecationNotice := false
	for i := typeLineIdx - 1; i >= 0 && i >= typeLineIdx-20; i-- {
		line := strings.TrimSpace(lines[i])
		if strings.Contains(line, "Deprecated:") && strings.Contains(content, expectedNoticeSubstring) {
			hasDeprecationNotice = true
			break
		}
	}

	if shouldExist && !hasDeprecationNotice {
		t.Errorf("Expected deprecation notice containing %q in description of type %s, but not found", expectedNoticeSubstring, typeName)
	}
	if !shouldExist && hasDeprecationNotice {
		t.Errorf("Did not expect deprecation notice in description of type %s, but found one", typeName)
	}
}

// Helper function to verify marker is NOT present in the marker block before a specific type
func verifyMarkerNotNearType(t *testing.T, content, typeName, marker string) {
	t.Helper()
	lines := strings.Split(content, "\n")

	// Find the type declaration line
	typeLineIdx := -1
	for i, line := range lines {
		if strings.Contains(line, "type "+typeName+" struct {") {
			typeLineIdx = i
			break
		}
	}
	if typeLineIdx == -1 {
		// Type not found, that's okay for this check
		return
	}

	// Find the marker block immediately before this type (walk backwards from type line)
	// Stop at the first non-comment line or when we've gone back 15 lines
	markerBlockStart := typeLineIdx - 1
	for markerBlockStart >= 0 && markerBlockStart > typeLineIdx-15 {
		line := strings.TrimSpace(lines[markerBlockStart])
		if !strings.HasPrefix(line, "//") && line != "" {
			// Found a non-comment line, marker block starts after this
			markerBlockStart++
			break
		}
		markerBlockStart--
	}

	// Check only the marker block immediately before this type
	for i := markerBlockStart; i < typeLineIdx; i++ {
		if strings.TrimSpace(lines[i]) == marker {
			t.Errorf("marker %q found at line %d in marker block before type %s at line %d (should not be there)",
				marker, i, typeName, typeLineIdx)
			break
		}
	}
}

func TestUpdateFileMarkers(t *testing.T) {
	// Base content structure borrowed from a real generated file
	// apis/cluster/groups/v1beta1/zz_member_types.go from provider-upjet-azuread
	baseContent := `// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type MemberSpec struct {
	v1.ResourceSpec ` + "`json:\",inline\"`" + `
	ForProvider     MemberParameters ` + "`json:\"forProvider\"`" + `
}

type MemberStatus struct {
	v1.ResourceStatus ` + "`json:\",inline\"`" + `
	AtProvider        MemberObservation ` + "`json:\"atProvider,omitempty\"`" + `
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Member is the Schema for the Members API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azuread}
type Member struct {
	metav1.TypeMeta   ` + "`json:\",inline\"`" + `
	metav1.ObjectMeta ` + "`json:\"metadata,omitempty\"`" + `
	Spec              MemberSpec   ` + "`json:\"spec\"`" + `
	Status            MemberStatus ` + "`json:\"status,omitempty\"`" + `
}

// +kubebuilder:object:root=true

// MemberList contains a list of Members
type MemberList struct {
	metav1.TypeMeta ` + "`json:\",inline\"`" + `
	metav1.ListMeta ` + "`json:\"metadata,omitempty\"`" + `
	Items           []Member ` + "`json:\"items\"`" + `
}
`

	type args struct {
		content      string
		typeName     string
		version      string
		isServed     bool
		isDeprecated bool
		deprecation  config.VersionDeprecation
	}
	type want struct {
		contains    []string
		notContains []string
		err         bool
	}

	cases := map[string]struct {
		reason string
		args
		want
	}{
		"AddUnservedVersionMarker": {
			reason: "Should add unservedversion marker when version is not served.",
			args: args{
				content:      baseContent,
				typeName:     "Member",
				version:      "v1beta1",
				isServed:     false,
				isDeprecated: false,
				deprecation:  config.VersionDeprecation{},
			},
			want: want{
				contains: []string{
					"// +kubebuilder:storageversion",
					"// +kubebuilder:unservedversion",
					"// Member is the Schema for the Members API.",
				},
				notContains: []string{
					"// +kubebuilder:deprecatedversion",
				},
				err: false,
			},
		},
		"AddDeprecatedVersionMarker": {
			reason: "Should add deprecatedversion marker with enhanced warning when version is deprecated.",
			args: args{
				content:      baseContent,
				typeName:     "Member",
				version:      "v1beta1",
				isServed:     true,
				isDeprecated: true,
				deprecation: config.VersionDeprecation{
					Warning:               "v1beta1 Member is deprecated. Please use v1beta2.",
					DeprecationRelease:    "v1.5.0",
					PlannedRemovalRelease: "v1.7.0",
				},
			},
			want: want{
				contains: []string{
					"// +kubebuilder:storageversion",
					`// +kubebuilder:deprecatedversion:warning="v1beta1 Member is deprecated. Please use v1beta2. Deprecated since v1.5.0. Planned removal in v1.7.0."`,
					"// Member is the Schema for the Members API.",
				},
				notContains: []string{
					"// +kubebuilder:unservedversion",
				},
				err: false,
			},
		},
		"AddBothMarkers": {
			reason: "Should add both unservedversion and deprecatedversion markers with enhanced warning when version is unserved and deprecated.",
			args: args{
				content:      baseContent,
				typeName:     "Member",
				version:      "v1beta1",
				isServed:     false,
				isDeprecated: true,
				deprecation: config.VersionDeprecation{
					Warning:               "v1beta1 is deprecated and will be removed soon.",
					DeprecationRelease:    "v1.5.0",
					PlannedRemovalRelease: "v1.6.0",
				},
			},
			want: want{
				contains: []string{
					"// +kubebuilder:storageversion",
					"// +kubebuilder:unservedversion",
					`// +kubebuilder:deprecatedversion:warning="v1beta1 is deprecated and will be removed soon. Deprecated since v1.5.0. Planned removal in v1.6.0."`,
					"// Member is the Schema for the Members API.",
				},
				notContains: []string{},
				err:         false,
			},
		},
		"PreserveContentWhenServedAndNotDeprecated": {
			reason: "Should not add markers when version is served and not deprecated.",
			args: args{
				content:      baseContent,
				typeName:     "Member",
				version:      "v1beta1",
				isServed:     true,
				isDeprecated: false,
				deprecation:  config.VersionDeprecation{},
			},
			want: want{
				contains: []string{
					"// +kubebuilder:storageversion",
					"// Member is the Schema for the Members API.",
					"type Member struct {",
				},
				notContains: []string{
					"// +kubebuilder:unservedversion",
					"// +kubebuilder:deprecatedversion",
				},
				err: false,
			},
		},
		"UpdateExistingUnservedVersionMarker": {
			reason: "Should preserve unservedversion marker when version remains unserved.",
			args: args{
				content: strings.Replace(baseContent,
					"// +kubebuilder:storageversion\n",
					"// +kubebuilder:storageversion\n// +kubebuilder:unservedversion\n",
					1),
				typeName:     "Member",
				version:      "v1beta1",
				isServed:     false,
				isDeprecated: false,
				deprecation:  config.VersionDeprecation{},
			},
			want: want{
				contains: []string{
					"// +kubebuilder:storageversion",
					"// +kubebuilder:unservedversion",
				},
				notContains: []string{
					"// +kubebuilder:deprecatedversion",
				},
				err: false,
			},
		},
		"UpdateExistingDeprecatedVersionMarker": {
			reason: "Should replace old deprecation warning with new one.",
			args: args{
				content: strings.Replace(baseContent,
					"// +kubebuilder:storageversion\n",
					"// +kubebuilder:storageversion\n// +kubebuilder:deprecatedversion:warning=\"old warning\"\n",
					1),
				typeName:     "Member",
				version:      "v1beta1",
				isServed:     true,
				isDeprecated: true,
				deprecation: config.VersionDeprecation{
					Warning: "new warning message",
				},
			},
			want: want{
				contains: []string{
					"// +kubebuilder:storageversion",
					`// +kubebuilder:deprecatedversion:warning="new warning message"`,
				},
				notContains: []string{
					"old warning",
					"// +kubebuilder:unservedversion",
				},
				err: false,
			},
		},
		"RemoveMarkersWhenServedAndNotDeprecated": {
			reason: "Should remove existing lifecycle markers when version becomes served and not deprecated.",
			args: args{
				content: strings.Replace(baseContent,
					"// +kubebuilder:storageversion\n",
					"// +kubebuilder:storageversion\n// +kubebuilder:unservedversion\n// +kubebuilder:deprecatedversion:warning=\"test\"\n",
					1),
				typeName:     "Member",
				version:      "v1beta1",
				isServed:     true,
				isDeprecated: false,
				deprecation:  config.VersionDeprecation{},
			},
			want: want{
				contains: []string{
					"// +kubebuilder:storageversion",
					"// Member is the Schema for the Members API.",
				},
				notContains: []string{
					"// +kubebuilder:unservedversion",
					"// +kubebuilder:deprecatedversion",
				},
				err: false,
			},
		},
		"ErrorOnMissingType": {
			reason: "Should return error when type declaration is not found.",
			args: args{
				content:      baseContent,
				typeName:     "NonExistent",
				version:      "v1beta1",
				isServed:     false,
				isDeprecated: false,
				deprecation:  config.VersionDeprecation{},
			},
			want: want{
				err: true,
			},
		},
	}

	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			got, err := updateFileMarkers(tc.args.content, tc.args.typeName, tc.args.version, tc.args.isServed, tc.args.isDeprecated, tc.args.deprecation)
			if (err != nil) != tc.want.err {
				t.Errorf("\n%s\nupdateFileMarkers(...): error = %v, wantErr %v", tc.reason, err, tc.want.err)
				return
			}
			if tc.want.err {
				return
			}

			// Check that all expected strings are present
			for _, want := range tc.want.contains {
				if !strings.Contains(got, want) {
					t.Errorf("\n%s\nupdateFileMarkers(...): result does not contain expected string:\nwant: %q", tc.reason, want)
				}
			}

			// Check that unwanted strings are not present
			for _, notWant := range tc.want.notContains {
				if strings.Contains(got, notWant) {
					t.Errorf("\n%s\nupdateFileMarkers(...): result contains unexpected string:\ndon't want: %q", tc.reason, notWant)
				}
			}

			// Verify the structure is preserved
			if !strings.Contains(got, "type "+tc.args.typeName+" struct {") {
				t.Errorf("\n%s\nupdateFileMarkers(...): lost the type declaration for %s", tc.reason, tc.args.typeName)
			}

			// Verify marker positions if they should be present
			if !tc.args.isServed {
				verifyMarkerPosition(t, got, tc.args.typeName, "// +kubebuilder:unservedversion")
				// Verify unservedversion comes after storageversion if storageversion exists
				if strings.Contains(got, "// +kubebuilder:storageversion") {
					verifyMarkerOrder(t, got, "// +kubebuilder:storageversion", "// +kubebuilder:unservedversion")
				}
			}

			if tc.args.isDeprecated {
				// Build enhanced warning to match what's actually generated
				warning := tc.args.deprecation.Warning
				if warning == "" {
					warning = "This API version is deprecated."
				}
				if tc.args.deprecation.DeprecationRelease != "" {
					warning += fmt.Sprintf(" Deprecated since %s.", tc.args.deprecation.DeprecationRelease)
				}
				if tc.args.deprecation.PlannedRemovalRelease != "" {
					warning += fmt.Sprintf(" Planned removal in %s.", tc.args.deprecation.PlannedRemovalRelease)
				}

				expectedMarker := `// +kubebuilder:deprecatedversion:warning="` + warning + `"`
				verifyMarkerPosition(t, got, tc.args.typeName, expectedMarker)
				// Verify deprecatedversion comes after storageversion if storageversion exists
				if strings.Contains(got, "// +kubebuilder:storageversion") {
					verifyMarkerOrder(t, got, "// +kubebuilder:storageversion", expectedMarker)
				}
				// If both markers exist, verify deprecatedversion comes after unservedversion
				if !tc.args.isServed {
					verifyMarkerOrder(t, got, "// +kubebuilder:unservedversion", expectedMarker)
				}

				// Verify deprecation notice in description
				verifyDeprecationNotice(t, got, tc.args.typeName, tc.args.version, true)
			} else {
				// Verify no deprecation notice when not deprecated
				verifyDeprecationNotice(t, got, tc.args.typeName, tc.args.version, false)
			}

			// Verify markers don't appear near MemberList type (if it exists in content)
			if strings.Contains(got, "type MemberList struct {") {
				if !tc.args.isServed {
					verifyMarkerNotNearType(t, got, "MemberList", "// +kubebuilder:unservedversion")
				}
				if tc.args.isDeprecated {
					// Build enhanced warning to match what's actually generated
					warning := tc.args.deprecation.Warning
					if warning == "" {
						warning = "This API version is deprecated."
					}
					if tc.args.deprecation.DeprecationRelease != "" {
						warning += fmt.Sprintf(" Deprecated since %s.", tc.args.deprecation.DeprecationRelease)
					}
					if tc.args.deprecation.PlannedRemovalRelease != "" {
						warning += fmt.Sprintf(" Planned removal in %s.", tc.args.deprecation.PlannedRemovalRelease)
					}
					expectedMarker := `// +kubebuilder:deprecatedversion:warning="` + warning + `"`
					verifyMarkerNotNearType(t, got, "MemberList", expectedMarker)
				}
			}
		})
	}
}

func TestUpdateFileMarkers_MarkerOrdering(t *testing.T) {
	type args struct {
		content      string
		typeName     string
		version      string
		isServed     bool
		isDeprecated bool
		deprecation  config.VersionDeprecation
	}
	type want struct {
		markerOrder []string
	}

	cases := map[string]struct {
		reason string
		args
		want
	}{
		"CorrectMarkerOrderWithBothMarkers": {
			reason: "Markers should appear in correct order: storageversion, unservedversion, deprecatedversion.",
			args: args{
				content: `package v1beta1

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Member is the Schema for the Members API.
type Member struct {
	Spec MemberSpec
}
`,
				typeName:     "Member",
				version:      "v1beta1",
				isServed:     false,
				isDeprecated: true,
				deprecation: config.VersionDeprecation{
					Warning: "test warning",
				},
			},
			want: want{
				markerOrder: []string{
					"// +kubebuilder:object:root=true",
					"// +kubebuilder:subresource:status",
					"// +kubebuilder:storageversion",
					"// +kubebuilder:unservedversion",
					`// +kubebuilder:deprecatedversion:warning="test warning"`,
				},
			},
		},
	}

	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			got, err := updateFileMarkers(tc.args.content, tc.args.typeName, tc.args.version, tc.args.isServed, tc.args.isDeprecated, tc.args.deprecation)
			if err != nil {
				t.Fatalf("\n%s\nupdateFileMarkers(...): unexpected error = %v", tc.reason, err)
			}

			// Extract the marker section
			lines := strings.Split(got, "\n")
			var markers []string
			inMarkerSection := false
		lineLoop:
			for _, line := range lines {
				trimmed := strings.TrimSpace(line)
				switch {
				case strings.HasPrefix(trimmed, "// +kubebuilder:"):
					inMarkerSection = true
					markers = append(markers, trimmed)
				case inMarkerSection && strings.HasPrefix(trimmed, "//") && !strings.Contains(trimmed, "+kubebuilder:"):
					continue
				default:
					if inMarkerSection {
						// We've exited the marker section, stop processing
						break lineLoop
					}
				}
			}

			if diff := cmp.Diff(tc.want.markerOrder, markers); diff != "" {
				t.Errorf("\n%s\nupdateFileMarkers(...): marker order mismatch (-want +got):\n%s", tc.reason, diff)
			}
		})
	}
}

func TestAddStorageVersionMarker(t *testing.T) {
	baseContent := `// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

package v1beta1

type MemberSpec struct {
	Field string
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Member is the Schema for the Members API.
type Member struct {
	Spec MemberSpec
}
`

	type args struct {
		content  string
		typeName string
	}
	type want struct {
		contains    []string
		notContains []string
		err         bool
	}

	cases := map[string]struct {
		reason string
		args
		want
	}{
		"AddStorageVersionMarker": {
			reason: "Should add +kubebuilder:storageversion marker after subresource:status.",
			args: args{
				content:  baseContent,
				typeName: "Member",
			},
			want: want{
				contains: []string{
					"// +kubebuilder:object:root=true",
					"// +kubebuilder:subresource:status",
					"// +kubebuilder:storageversion",
					"// Member is the Schema for the Members API.",
					"type Member struct {",
				},
				notContains: []string{},
				err:         false,
			},
		},
		"MarkerOrderCorrect": {
			reason: "Storage version marker should appear after subresource marker.",
			args: args{
				content:  baseContent,
				typeName: "Member",
			},
			want: want{
				contains: []string{
					"// +kubebuilder:subresource:status",
					"// +kubebuilder:storageversion",
				},
				notContains: []string{},
				err:         false,
			},
		},
		"ErrorOnMissingType": {
			reason: "Should return error when type is not found.",
			args: args{
				content:  baseContent,
				typeName: "NonExistent",
			},
			want: want{
				err: true,
			},
		},
	}

	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			got, err := addStorageVersionMarker(tc.args.content, tc.args.typeName)
			if (err != nil) != tc.want.err {
				t.Errorf("\n%s\naddStorageVersionMarker(...): error = %v, wantErr %v", tc.reason, err, tc.want.err)
				return
			}
			if tc.want.err {
				return
			}

			// Check that all expected strings are present
			for _, want := range tc.want.contains {
				if !strings.Contains(got, want) {
					t.Errorf("\n%s\naddStorageVersionMarker(...): result does not contain expected string:\nwant: %q", tc.reason, want)
				}
			}

			// Check that unwanted strings are not present
			for _, notWant := range tc.want.notContains {
				if strings.Contains(got, notWant) {
					t.Errorf("\n%s\naddStorageVersionMarker(...): result contains unexpected string:\ndon't want: %q", tc.reason, notWant)
				}
			}

			// Verify marker appears only once
			count := strings.Count(got, "// +kubebuilder:storageversion")
			if count != 1 {
				t.Errorf("\n%s\naddStorageVersionMarker(...): storageversion marker appears %d times, want 1", tc.reason, count)
			}

			// Verify marker order: subresource should come before storageversion
			subresourceIdx := strings.Index(got, "// +kubebuilder:subresource:status")
			storageIdx := strings.Index(got, "// +kubebuilder:storageversion")
			if subresourceIdx != -1 && storageIdx != -1 && storageIdx < subresourceIdx {
				t.Errorf("\n%s\naddStorageVersionMarker(...): storageversion marker should come after subresource marker", tc.reason)
			}
		})
	}
}

func TestRemoveStorageVersionMarker(t *testing.T) {
	baseContentWithMarker := `// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

package v1beta1

type MemberSpec struct {
	Field string
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Member is the Schema for the Members API.
type Member struct {
	Spec MemberSpec
}
`

	type args struct {
		content  string
		typeName string
	}
	type want struct {
		contains    []string
		notContains []string
		err         bool
	}

	cases := map[string]struct {
		reason string
		args
		want
	}{
		"RemoveStorageVersionMarker": {
			reason: "Should remove +kubebuilder:storageversion marker.",
			args: args{
				content:  baseContentWithMarker,
				typeName: "Member",
			},
			want: want{
				contains: []string{
					"// +kubebuilder:object:root=true",
					"// +kubebuilder:subresource:status",
					"// Member is the Schema for the Members API.",
					"type Member struct {",
				},
				notContains: []string{
					"// +kubebuilder:storageversion",
				},
				err: false,
			},
		},
		"PreserveOtherMarkers": {
			reason: "Should preserve other kubebuilder markers when removing storageversion.",
			args: args{
				content:  baseContentWithMarker,
				typeName: "Member",
			},
			want: want{
				contains: []string{
					"// +kubebuilder:object:root=true",
					"// +kubebuilder:subresource:status",
				},
				notContains: []string{
					"// +kubebuilder:storageversion",
				},
				err: false,
			},
		},
	}

	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			got, err := removeStorageVersionMarker(tc.args.content, tc.args.typeName)
			if (err != nil) != tc.want.err {
				t.Errorf("\n%s\nremoveStorageVersionMarker(...): error = %v, wantErr %v", tc.reason, err, tc.want.err)
				return
			}
			if tc.want.err {
				return
			}

			// Check that all expected strings are present
			for _, want := range tc.want.contains {
				if !strings.Contains(got, want) {
					t.Errorf("\n%s\nremoveStorageVersionMarker(...): result does not contain expected string:\nwant: %q", tc.reason, want)
				}
			}

			// Check that unwanted strings are not present
			for _, notWant := range tc.want.notContains {
				if strings.Contains(got, notWant) {
					t.Errorf("\n%s\nremoveStorageVersionMarker(...): result contains unexpected string:\ndon't want: %q", tc.reason, notWant)
				}
			}

			// Verify marker is completely removed (count should be 0)
			count := strings.Count(got, "// +kubebuilder:storageversion")
			if count != 0 {
				t.Errorf("\n%s\nremoveStorageVersionMarker(...): storageversion marker appears %d times, want 0", tc.reason, count)
			}
		})
	}
}

func TestAddRemoveStorageVersionMarkerRoundTrip(t *testing.T) {
	baseContent := `package v1beta1

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Member is the Schema for the Members API.
type Member struct {
	Spec MemberSpec
}
`

	// Add marker
	withMarker, err := addStorageVersionMarker(baseContent, "Member")
	if err != nil {
		t.Fatalf("addStorageVersionMarker() error = %v", err)
	}

	// Verify marker was added
	if !strings.Contains(withMarker, "// +kubebuilder:storageversion") {
		t.Error("addStorageVersionMarker() did not add the marker")
	}

	// Remove marker
	withoutMarker, err := removeStorageVersionMarker(withMarker, "Member")
	if err != nil {
		t.Fatalf("removeStorageVersionMarker() error = %v", err)
	}

	// Verify marker was removed
	if strings.Contains(withoutMarker, "// +kubebuilder:storageversion") {
		t.Error("removeStorageVersionMarker() did not remove the marker")
	}

	// The result should be similar to original (allowing for whitespace differences)
	if !strings.Contains(withoutMarker, "// +kubebuilder:object:root=true") {
		t.Error("Other markers were lost during round trip")
	}
	if !strings.Contains(withoutMarker, "type Member struct {") {
		t.Error("Type declaration was lost during round trip")
	}
}
