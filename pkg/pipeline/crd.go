// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

package pipeline

import (
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	twtypes "github.com/muvaf/typewriter/pkg/types"
	"github.com/muvaf/typewriter/pkg/wrapper"
	"github.com/pkg/errors"

	tjpkg "github.com/crossplane/upjet/pkg"
	"github.com/crossplane/upjet/pkg/config"
	"github.com/crossplane/upjet/pkg/pipeline/templates"
	tjtypes "github.com/crossplane/upjet/pkg/types"
)

const (
	// GenStatement is printed on every generated file.
	GenStatement = "// Code generated by upjet. DO NOT EDIT."
)

// NewCRDGenerator returns a new CRDGenerator.
func NewCRDGenerator(pkg *types.Package, apiDir, hackDir, providerShortName, group, version, scope string) *CRDGenerator {
	return &CRDGenerator{
		LocalDirectoryPath: filepath.Join(apiDir, strings.ToLower(strings.Split(group, ".")[0]), version),
		LicenseHeaderPath:  filepath.Join(hackDir, "boilerplate.go.txt"),
		Group:              group,
		Scope:              scope,
		ProviderShortName:  providerShortName,
		pkg:                pkg,
	}
}

// CRDGenerator takes certain information referencing Terraform resource definition
// and writes kubebuilder CRD file.
type CRDGenerator struct {
	LocalDirectoryPath string
	Group              string
	Scope              string // TODO(negz): Make this a constant.
	ProviderShortName  string
	LicenseHeaderPath  string
	Generated          *tjtypes.Generated

	pkg *types.Package
}

// Generate builds and writes a new CRD out of Terraform resource definition.
func (cg *CRDGenerator) Generate(cfg *config.Resource) (string, error) {
	file := wrapper.NewFile(cg.pkg.Path(), cg.pkg.Name(), templates.CRDTypesTemplate,
		wrapper.WithGenStatement(GenStatement),
		wrapper.WithHeaderPath(cg.LicenseHeaderPath),
	)

	deleteOmittedFields(cfg.TerraformResource.Schema, cfg.ExternalName.OmittedFields)
	cfg.TerraformResource.Schema["id"] = &schema.Schema{
		Type:     schema.TypeString,
		Computed: true,
	}

	gen, err := tjtypes.NewBuilder(cg.pkg).Build(cfg)
	if err != nil {
		return "", errors.Wrapf(err, "cannot build types for %s", cfg.Kind)
	}
	cg.Generated = &gen

	// TODO(muvaf): TypePrinter uses the given scope to see if the type exists
	// before printing. We should ideally load the package in file system but
	// loading the local package will result in error if there is
	// any compilation errors, which is the case before running kubebuilder
	// generators. For now, we act like the target package is empty.
	pkg := types.NewPackage(cg.pkg.Path(), cg.pkg.Name())
	typePrinter := twtypes.NewPrinter(file.Imports, pkg.Scope(), twtypes.WithComments(gen.Comments))
	typesStr, err := typePrinter.Print(gen.Types)
	if err != nil {
		return "", errors.Wrap(err, "cannot print the type list")
	}
	vars := map[string]any{
		"Types": typesStr,
		"CRD": map[string]string{
			"APIVersion":         cfg.Version,
			"Group":              cg.Group,
			"Kind":               cfg.Kind,
			"MarkStorageVersion": strconv.FormatBool(cfg.CRDStorageVersion() == cfg.Version),
			"ForProviderType":    gen.ForProviderType.Obj().Name(),
			"InitProviderType":   gen.InitProviderType.Obj().Name(),
			"AtProviderType":     gen.AtProviderType.Obj().Name(),
			"ValidationRules":    gen.ValidationRules,
			"Path":               cfg.Path,
			"Scope":              cg.Scope,
		},
		"Provider": map[string]string{
			"ShortName": cg.ProviderShortName,
		},
		"XPCommonAPIsPackageAlias": file.Imports.UsePackage(tjtypes.PackagePathXPCommonAPIs),
	}
	if cfg.MetaResource != nil {
		// remove sentences with the `terraform` keyword in them
		vars["CRD"].(map[string]string)["Description"] = tjpkg.FilterDescription(cfg.MetaResource.Description, tjpkg.TerraformKeyword)
	}
	filePath := filepath.Join(cg.LocalDirectoryPath, fmt.Sprintf("zz_%s_types.go", strings.ToLower(cfg.Kind)))
	return gen.ForProviderType.Obj().Name(), errors.Wrap(file.Write(filePath, vars, os.ModePerm), "cannot write crd file")
}

func deleteOmittedFields(sch map[string]*schema.Schema, omittedFields []string) {
	for _, omit := range omittedFields {
		fields := strings.Split(omit, ".")
		current := sch
		for i, f := range fields {
			if i == len(fields)-1 {
				delete(current, f)
				break
			}
			current = current[f].Elem.(*schema.Resource).Schema
		}
	}
}
